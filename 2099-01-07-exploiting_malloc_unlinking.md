---
title:  "Lecture Notes: Exploiting Malloc Unlinking"
date:   2020-04-12 09:00:00
categories: notes lecture
layout: post
challenges: heap1r heap3r
---


Another way to create a write-what-where vulnerability is to exploit the
unlinking behavior of malloc's freelist.  The basic idea of the attack is as
follows. We are going to manipulate the metadata of the free memory chunks
stored in the freelist such that when malloc re-allocates a particular chunk
(i.e., unlinking that chunk from the freelist) malloc will write an
attacker-provided value to an attacker-provided location. We give the full
details below.

Recall that `malloc` is going to start its operation by grabbing a large,
contiguous, region of memory of from the OS to form the heap. Whenever a
function calls `malloc`, `malloc` is going to take a piece of that memory,
called a **chunk**, and return a pointer to the calling function. Also recall,
that malloc writes a header for each chunk so that it can keep track of
important metadata.

If we take a closer look at a single chunk (one that is in use) the
header looks like the following:


```
CHUNK FOO: In use

               pointer returned
               by malloc()
               ^
size of prev.  |
chunk          |
    ^          |
    |          |
    +----+----++----------------------------------------------------------+
    |    |    | USER DATA....                                             |
    +----+-+--+-----------------------------------------------------------+
           v
           size of this
           chunk
           
Note: In some version of malloc, the lowest order bit is set to indicate if the
previous chunk is in use.

```


Whenever the program makes a request via `malloc()`, malloc is going to pick
one of the free chunks and give it to the process. When the program `frees`
memory, malloc adds it back to the list of free chunks.  After the process has
been executing for a while---and a number of chunks have been allocated and
freed---the heap will start to look  something like this:

```
+----------------------------------------------------------------------------+
|XXXXX       XXXXXXXXXX     XXXXXXXXXXXXXXXXX        XXXXXXXXXXXX            |
+----------------------------------------------------------------------------+
         XX: Used Chunk

```

Notice that free and used chunks are interspersed throughout the heap, so
malloc has to use some mechanism to keep track of where the free chunks are in
memory. This mechanism is a doubly-linked list of free chunks called a
**free list**.

Now imagine a scenario where the program has freed a particular chunk. Malloc
will update the header of the now-freed chunk to add forward and backward
pointers, inserting the chunk into the freelist. These new pointers actually
overwrite the first 8 bytes of the user data that was stored in the chunk
(before it was freed). 

```
CHUNK FOO: After being freed

               Next chunk in freelist
               ^
size of prev.  |
chunk          |
    ^          |
    |          |
    +----+----++----------------------------------------------------------+
    |    |    | FWD | BCK |   Old data                                    |
    +----+-+--+-----------------------------------------------------------+
                     |
                     v
                     Previous chunk in freelist

```

Keep in mind that free chunks are likely scattered throughout the heap, so the
next chunk in the freelist (i.e., the chunk pointed to by`FWD`) is not
necessarily adjacent in memory to `chunk foo`. 

When we unlink a chunk from the freelist, we have to update the pointers to
remove the unlinked chunk. The key point is that `malloc` uses the `FWD` and
`BCK` pointers stored in the chunk  to figure out what needs updating. 

Imagine that chunk bar and chunk foo are adjacent in memory. Further, chunk bar
is in use while chunk foo is free. An attacker can overflow a buffer in chunk
bar to overwrite the forward and backward freelist pointers in chunk foo. If
the forward pointer is changed to point to the target return address (on the
stack) and the backward pointer is changed to point to the injected code (on
the heap), the freelist unlinking process will overwrite the return address
with the address of the injected code. Of course, the attacker needs to trigger
the unlinking process (i.e., force malloc to reallocate that memory).  


```
CHUNK Bar                              CHUNK Foo
  in use                               in free list
     +----------------------------------------+
     |                                        |
     |                             +          |
     V                             |          |
+---------------------------------------------+------------------+
|S|S|INJECTED CODE                 ||S|S|FWD|BCK|                |
+-----------------------------------------+----------------------+
                                   |      |
                                   +      |
                                          V
                                      +-------+
                                      |ret    |
                                      +-------+
```


**A major caveat:** Real malloc implementations are a lot more complicated than
what we have presented here. The specific behavior we  want to exploit will
depend on the implementation of malloc (and there are a lot of
implementations). For example, this LiveOverflow video describes how [dlmalloc
handles fastbins][fastbins]. 

[fastbins]: https://youtu.be/gL45bjQvZSU
